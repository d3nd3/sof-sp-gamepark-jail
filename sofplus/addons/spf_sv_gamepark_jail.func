// ---------------------------------------------------------------------------
// rcon extended : Some extra commands to give the admins more control against griefers.
// ---------------------------------------------------------------------------
function spf_sv_gamepark_jail_init()
{
    sp_sc_func_exec spf_sc_list_add_func _sp_sv_on_map_begin "spf_sv_gamepark_jail_on_map_begin"
    
    sp_sc_func_exec spf_sc_list_add_func _sp_sv_on_client_disconnect "spf_sv_gamepark_jail_on_cl_disc"
    sp_sc_func_exec spf_sc_list_add_func _sp_sv_on_client_begin "spf_sv_gamepark_jail_on_cl_join"

    sp_sc_func_exec spf_sv_gamepark_jail_on_map_begin

    //ms for all jailees to be checked
    set _spf_sv_jail_loopms 2500
    //lives of hopping back in abuse
    set _spf_sv_jail_maxlives 3
    //votes required from other players in server to jail someone.
    set _spf_sv_jail_maxvotes 3
    
    
    sp_sc_func_exec spf_sv_gamepark_jail_loop
}

function spf_sv_gamepark_jail_on_map_begin()
{
    set ~i 0
    sp_sc_flow_while number cvar ~i < cvar maxclients
    {
        zero _spf_sv_rcon_jailed_$~i
        set _spf_sv_rcon_jailed_lives_$~i 0
        // per-slot vote flag: cleared at map begin
        zero _spf_sv_rcon_jailed_voted_$~i

        add ~i 1
    }

    set _spf_sv_jailed_count 0
    //clear the jailee ip list.
    zero _spf_sv_jail_iplist
    
    //is voting in progress
    zero _spf_sv_rcon_jailed_voting
    zero _spf_sv_jail_votes
    set _spf_sv_rcon_jailed_vote_starter -1
}

function spf_sv_gamepark_jail_on_cl_disc(*)
{
    zero _spf_sv_rcon_jailed_$~1
    set _spf_sv_rcon_jailed_lives_$~1 0
    // clear per-slot vote flag on disconnect
    zero _spf_sv_rcon_jailed_voted_$~1
    
}

function spf_sv_gamepark_jail_on_cl_join(*)
{
    //slot jailed
    zero _spf_sv_rcon_jailed_$~1
    //hop in lives
    set _spf_sv_rcon_jailed_lives_$~1 0
    // clear per-slot vote flag on join
    zero _spf_sv_rcon_jailed_voted_$~1

    sp_sc_flow_if number cvar _spf_sv_jailed_count > val 0
    {

        sp_sv_info_client #~1

        //re-apply jailees if they reconnect during same map.
        sp_sc_cvar_split ~split , _spf_sv_jail_iplist
        
        set ~i 1
        
        sp_sc_flow_while number cvar ~i <= cvar ~split_0
        {
            sp_sc_cvar_copy ~jailee_ip ~split_$~i
            sp_sc_flow_if text cvar _sp_sv_info_client_ip == cvar ~jailee_ip
            {
                //a jailee has returned.
                //they don't get their lives back.
                set ~max_add_1 1
                add ~max_add_1 #_spf_sv_jail_maxlives
                sp_sc_cvar_copy _spf_sv_rcon_jailed_lives_$~1 ~max_add_1
                sp_sv_client_spec #~1
                sp_sc_cvar_sset ~jailed _spf_sv_rcon_jailed_ #~1
                set #~jailed 1

                set ~msg "%03Welcome back prisoner%04, get back in your %02cell!"
                sp_sc_cvar_unescape ~msg ~msg

                sp_sv_print_client #~1 #~msg
            }
            add ~i 1
        }
    }
}

function spf_sv_gamepark_jail_loop()
{
    sp_sc_flow_if number cvar _spf_sv_jailed_count > val 0
    {
        set ~i 0
        sp_sc_flow_while number cvar ~i < cvar maxclients
        {
            sp_sv_info_client $~i
            sp_sc_flow_if text cvar _sp_sv_info_client_ip != val ""
            {
                sp_sc_cvar_copy ~jailed _spf_sv_rcon_jailed_$~i
                sp_sc_flow_if text cvar ~jailed != val ""
                {
            
                    //is the jailee out of spec?
                    sp_sc_flow_if number cvar _sp_sv_info_client_spectator == val 0
                    {
                        sp_sc_flow_if number cvar _spf_sv_rcon_jailed_lives_$~i > cvar _spf_sv_jail_maxlives
                        {
                            //out of lives so kick
                            kick $~i
                        }
                        else
                        {
                            //put him back into spec, decrement life
                            sp_sv_client_spec $~i
                            add _spf_sv_rcon_jailed_lives_$~i 1
                        }
                
                    }
                }
            }
        
            add ~i 1
        }
    }

    sp_sc_timer #_spf_sv_jail_loopms "sp_sc_func_exec spf_sv_gamepark_jail_loop" 
}

function spf_sv_gamepark_jail_vote_loop(~jailee_slot, ~admin_display , ~jailee_display , ~jailee_ip, ~start_time, ~map_count)
{
    
    sp_sc_cvar_copy ~votes_needed _spf_sv_jail_maxvotes 
    sp_sc_cvar_math_sub ~votes_needed #_spf_sv_jail_votes

    set ~vote_ended 0
    //do once
    sp_sc_flow_if text cvar _spf_sv_rcon_jailed_voting == val ""
    {
        sset ~msg %04Admin #~admin_display %04has voted to jail #~jailee_display %04... supply #~votes_needed votes if guilty.
        sp_sc_cvar_unescape ~msg ~msg
        sp_sv_print_broadcast #~msg

        //Voting in progress
        set _spf_sv_rcon_jailed_voting 1
    }
    else
    {

        sp_sc_flow_if number cvar _spf_sv_jail_votes >= cvar _spf_sv_jail_maxvotes
        {
            set ~vote_ended 1

            add _spf_sv_jailed_count 1
            //perform the jail - guilty
            sp_sv_client_spec #~jailee_slot
            sp_sc_cvar_sset ~jailed _spf_sv_rcon_jailed_ #~jailee_slot
            set #~jailed 1

            
            sp_sc_func_exec spf_sc_list_add _spf_sv_jail_iplist #~jailee_ip ","

            sset ~msg %04Vote to jail #~jailee_display %04for the duration of this map %03succeeded %04: assume %02guilty.
            sp_sc_cvar_unescape ~msg ~msg
            sp_sv_print_broadcast #~msg

            sset ~msg %04Atleast #_spf_sv_jail_maxvotes players in the server have agreed to jail $02you for the duration of this map. %04Report abuse to discord. Else learn your lesson.
            sp_sc_cvar_unescape ~msg ~msg
            sp_sv_print_client #~jailee_slot #~msg
        }
        else
        {

            sp_sc_info_time
            sp_sc_cvar_math_sub _sp_sc_info_time_sec #~start_time
            sp_sc_flow_if number cvar _sp_sc_info_time_sec > val 30
            {
                set ~vote_ended 1
                sset ~msg %04Vote to jail #~jailee_display %02failed %04: assume %03innocent.
                sp_sc_cvar_unescape ~msg ~msg
                sp_sv_print_broadcast #~msg
            }
            else
            {
                sset ~msg %04Jail #~jailee_display %04vote active. #~votes_needed votes until jail. Are they guilty? type %03.jail %04if they are.
                sp_sc_cvar_unescape ~msg ~msg
                sp_sv_print_broadcast #~msg
            }

            
        }
        
    }
    
    sp_sc_flow_if number cvar _sp_sv_info_map_count > cvar ~map_count
    {
        //vote across map loads, end the loop
        set ~vote_ended 1
    }
    
    sp_sc_flow_if number cvar ~vote_ended == val 0
    {
        sp_sc_cvar_sset ~cmd "sset ~dd sp_sc_func_exec spf_sv_gamepark_jail_vote_loop %22" #~jailee_slot "%22%20%22" #~admin_display "%22%20%22" #~jailee_display "%22%20%22" #~jailee_ip "%22%20%22" #~start_time "%22%20%22" #~map_count "%22"
        sp_sc_cvar_append ~cmd ";sp_sc_cvar_unescape ~dd ~dd;$~dd"
        sp_sc_timer 5000 #~cmd
    }
    else
    {
        //Voting has ended.
        //Allow other votes to start. Reset variables.
        //clear per-slot voted flags and the vote starter
        set ~i 0
        sp_sc_flow_while number cvar ~i < cvar maxclients
        {
            zero _spf_sv_rcon_jailed_voted_$~i
            add ~i 1
        }
        set _spf_sv_rcon_jailed_vote_starter -1

        zero _spf_sv_rcon_jailed_voting
        zero _spf_sv_jail_votes

    }
}

//add this line into spf_sv_rcon.func file
//set ~command_jail "spf_sv_rcon_jail;1;.rcon jail <slot>"
//and add jail to the spf_sv_gamepark.func file also
function spf_sv_rcon_jail( ~par_slot, ~par_jail_slot )
{
    //test if number
    add ~par_jail_slot 0
    sp_sc_flow_if number cvar ~par_jail_slot >= val 0
    {
        sp_sc_flow_if number cvar ~par_jail_slot < cvar maxclients
        {
            //voting in progress
            sp_sc_flow_if text cvar _spf_sv_rcon_jailed_voting == val ""
            {
                sp_sv_info_client #~par_jail_slot

                sp_sc_flow_if text cvar _sp_sv_info_client_ip != val ""
                {
                    sset ~msg %03OK: Started vote to jail the accused.
                    sp_sc_cvar_unescape ~msg ~msg
                    sp_sv_print_client #~par_slot #~msg

                    sp_sc_cvar_copy ~jailee_name _sp_sv_info_client_name
                    sp_sc_cvar_escape ~jailee_name ~jailee_name
                    // create display name with slot and single quotes: '[slot]name'
                    sp_sc_cvar_sset ~jailee_display '[ #~par_jail_slot ] #~jailee_name '

                    echo slot #~par_slot voted to jail #~par_jail_slot
            
                    //start the vote
                    set _spf_sv_jail_votes 1 
                    sp_sv_info_client #~par_slot
                    sp_sc_cvar_copy ~admin_name _sp_sv_info_client_name 
                    sp_sc_cvar_escape ~admin_name ~admin_name
                    // create display name with slot and single quotes: '[slot]name'
                    sp_sc_cvar_sset ~admin_display '[ #~par_slot ] #~admin_name '

                    // record which slot started the vote and mark starter as having voted
                    set _spf_sv_rcon_jailed_vote_starter #~par_slot
                    set _spf_sv_rcon_jailed_voted_#~par_slot 1

                    sp_sc_info_time
                    // pass display names to vote loop so printed messages include '[slot]name'
                    sp_sc_func_exec spf_sv_gamepark_jail_vote_loop #~par_jail_slot #~admin_display #~jailee_display #_sp_sv_info_client_ip #_sp_sc_info_time_sec #_sp_sv_info_map_count
                }
                else
                {
                    sset ~msg %02ERROR: Provided slot id is not in use.
                    sp_sc_cvar_unescape ~msg ~msg
                    sp_sv_print_client #~par_slot #~msg
                }
        
            }
            else
            {
                sset ~msg %02ERROR: Jail voting is already in progress, try again later.
                sp_sc_cvar_unescape ~msg ~msg
                sp_sv_print_client #~par_slot #~msg
            }
        }
        else
        {
            set ~msg "%02ERROR: Illegal slot id."
            sp_sc_cvar_unescape ~msg ~msg
            sp_sv_print_client #~par_slot #~msg
        }
    }
    
    
}

function .jail(~par_slot, *)
{
    //vote in progress
    sp_sc_flow_if text cvar _spf_sv_rcon_jailed_voting != val ""
    {
        // Prevent the slot that started the vote from voting and prevent duplicate votes per slot
        sp_sc_cvar_copy ~starter _spf_sv_rcon_jailed_vote_starter
        sp_sc_flow_if number cvar ~par_slot == cvar ~starter
        {
            // starter cannot vote
            sset ~msg %02ERROR: Vote starter cannot vote.
            sp_sc_cvar_unescape ~msg ~msg
            sp_sv_print_client #~par_slot #~msg
        }
        else
        {
            // Check if this slot already voted
            sp_sc_cvar_copy ~voted_flag _spf_sv_rcon_jailed_voted_$~par_slot
            sp_sc_flow_if text cvar ~voted_flag == val ""
            {
                // mark vote from this slot
                set _spf_sv_rcon_jailed_voted_$~par_slot 1
                add _spf_sv_jail_votes 1
                sset ~msg %04Received a vote to jail the accused. type %03.jail %04if you agree
                sp_sc_cvar_unescape ~msg ~msg
                sp_sv_print_broadcast  #~msg
            }
            else
            {
                sset ~msg %02ERROR: You already voted.
                sp_sc_cvar_unescape ~msg ~msg
                sp_sv_print_client #~par_slot #~msg
            }
        }
    }
}